# ~~~~~~~~~~~~~~~ Functions ~~~~~~~~~~~~~~~~~~~~~~~~

# The 'extract' function supports extraction of 'gz', 'bz2', and 'zip' files to a new folder.
# It takes the source file as an argument and reports unsupported file types.
extract() {
	file=$1                                 # Get the input file from the argument
	extension="${file##*.}"                 # Get the file's extension
	filename_without_extension="${file%.*}" # Get the file's name without extension

	echo "Extracting '$file' to the folder '$filename_without_extension'"

	case $extension in
	gz)
		mkdir -p "$filename_without_extension"
		tar -xzf "$file" -C "$filename_without_extension" >/dev/null
		;;
	bz2)
		mkdir -p "$filename_without_extension"
		tar -xjf "$file" -C "$filename_without_extension" >/dev/null
		;;
	zip)
		mkdir -p "$filename_without_extension"
		unzip -q "$file" -d "$filename_without_extension"
		;;
	*)
		echo "Unsupported file type..."
		return 1
		;;
	esac
}

# The function 'cleanteams' is used to clean cached files for Microsoft Teams on a macOS system.
# It removes specific cached files and informs the user before and after the operation.
cleanteams() {
	echo "Cleaning Teams cache..."
	rm -rf ~/Library/Caches/com.microsoft.teams

	cd ~/Library/Application\ Support/Microsoft/Teams || exit
	rm ~/Library/Application\ Support/Microsoft/Teams/desktop-config.json
	rm ~/Library/Application\ Support/Microsoft/Teams/storage.json
	rm ~/Library/Application\ Support/Microsoft/Teams/Network\ Persistent\ State

	rm -rf ~/Library/Application\ Support/Microsoft/Teams/*Cache*
	rm -rf ~/Library/Application\ Support/Microsoft/Teams/blob_storage
	rm -rf ~/Library/Application\ Support/Microsoft/Teams/databases
	rm -rf ~/Library/Application\ Support/Microsoft/Teams/IndexedDB
	rm -rf ~/Library/Application\ Support/Microsoft/Teams/Local\ Storage
	rm -rf ~/Library/Application\ Support/Microsoft/Teams/tmp
	echo "Teams cache cleaned."
}

# The 'compress_current_folder' function compresses the current working directory into a zip file.
# The compressed file is saved to the parent folder and the user is informed before and after the operation.
compress_current_folder() {
	current_folder=$(basename "$(pwd)")
	parent_folder=$(dirname "$(pwd)")
	zipfile="$parent_folder/$current_folder.zip"

	echo "Compressing current folder to '$zipfile'"

	zip -r "$zipfile" . >/dev/null
	echo "Compression completed."
}

# 'webjpeg' function resizes, optimizes and converts images to JPEG format using ImageMagick.
# Takes 3 arguments: source file, target size, and output file.
webjpeg() {
	magick "$1" -sampling-factor 4:2:0 -strip -quality 85 -interlace JPEG -colorspace sRGB -resize "$2" "$3"
}

cropjpeg() {
	magick "$1" -gravity center -crop "$2" "$3"
}

# This function is stolen from rwxrob

clone() {
	local repo="$1"
	local user name host userd path ssh_url

	# Determine if the URL is SSH or HTTPS
	if [[ "$repo" =~ ^git@ ]]; then
		# It's an SSH URL
		ssh_url=true
		repo="${repo#git@}"
	else
		# It's an HTTPS URL
		ssh_url=false
		repo="${repo#https://}"
	fi

	echo "repo1: $repo"

	# Extract the host (e.g., github.com or gitlab.com)
	if [[ "$ssh_url" = true ]]; then
		host="${repo%%:*}"
		repo="${repo#*:}"
	else
		host="${repo%%/*}"
		repo="${repo#"$host/"}"
	fi
	echo "host: $host"
	echo "repo: $repo"

	# Extract the user and repo name
	if [[ $repo =~ / ]]; then
		user="${repo%%/*}"
		name="${repo#*/}"
	else
		user="$GITUSER"
		[[ -z "$user" ]] && user="$USER"
		name="$repo"
	fi

	# Remove .git suffix if present
	name="${name%.git}"
	echo "user: $user"
	echo "name: $name"

	userd="$REPOS/$host/$user"
	echo "userd: $userd"
	path="$userd/$name"
	echo "path: $path"

	# If the directory already exists, change to it and return
	[[ -d "$path" ]] && cd "$path" && return

	# Create the directory structure and change to it
	mkdir -p "$userd"
	cd "$userd" || exit

	# Clone the repository using git
	if [ "$ssh_url" = true ]; then
		echo "git clone git@$host:$user/$name.git --recurse-submodules"
		git clone "git@$host:$user/$name.git" --recurse-submodules
	else
		echo "git clone https://$host/$user/$name --recurse-submodules"
		git clone "https://$host/$user/$name" --recurse-submodules
	fi

	# Change to the cloned repository directory
	cd "$name" || exit
}

ghclone() {
	local repo="$1" user
	local repo="${repo#https://github.com/}"
	local repo="${repo#git@github.com:}"
	if [[ $repo =~ / ]]; then
		user="${repo%%/*}"
	else
		user="$GITUSER"
		[[ -z "$user" ]] && user="$USER"
	fi
	local name="${repo##*/}"
	local userd="$REPOS/github.com/$user"
	local path="$userd/$name"
	[[ -d "$path" ]] && cd "$path" && return
	mkdir -p "$userd"
	cd "$userd"
	echo gh repo clone "$user/$name" -- --recurse-submodule
	gh repo clone "$user/$name" -- --recurse-submodule
	cd "$name"
} && export -f clone

html_to_md() {
	# Check if the argument count is correct
	if [ "$#" -ne 1 ]; then
		echo "Usage: html_to_md <filename.html>"
		return 1
	fi

	# Extract filename without extension
	input_file="$1"
	base_name="${input_file%.html}"

	# Run pandoc command with resource path setting
	pandoc --resource-path="$(dirname "$input_file")" -f html -t markdown "$input_file" -o "${base_name}.md"
}
